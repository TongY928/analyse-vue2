## 为什么要异步更新

试想一个场景，我们在触发了一个点击事件，在回调函数中我们会连续改变某个状态的值 `1000` 次。按照正常情况，我们每一次改变状态的值，都会触发 `set` 函数，然后通知依赖，依赖再去通知虚拟 `DOM` 重新渲染。那么回调的过程会重新渲染 `1000` 次吗？

答案当然不会，这种方法极其低效。`Vue` 在默认情况下，每次触发某个状态的 `getter`，闭包中的 `Dep` 会触发依赖列表中的 `watcher` 实例的 `update` 方法。对应的 `Watcher` 实例其实会被 `push` 进一个队列中，在下一次 `tick` 的时候将这个队列中的 `Watcher` 全部拿出来依次触发 `patch`，进行更新视图。

并且针对相同的依赖还会进行合并，最后进行更新的是合并后的，所有修改只在一次更新中进行。

这个 `tick` 在 `vue` 内部就是 `nextTick`。

## nextTick

`Vue` 内部实现了一个 `nextTick` 函数。`nextTick` 函数的原理是，在微任务队列或者宏任务队列中推入一个 `function`， 在当前执行栈执行完毕后，执行 `nextTick` 传入的 `function`。 这个的 `function`，就是 `flushSchedulerQueue`。

`nextTick` 在实现任务推送的过程中，有三种方案，`Promise`、 `MutationObserver`、 `setImmediate`、 `setTimeout`。前两者都会把 `function` 添加到微任务队列中，后两者会把 `function` 添加到宏任务队列中。使用的优先级跟我们列出的顺序一致。

为什么要优先使用微任务？ 在 `JS` 的 `Event loop` 中，每个宏任务执行运行完后，`UI` 都会重新渲染，宏任务执行完毕后，会去检查自己的微任务队列，执行所有的微任务。那么我们在微任务中完成数据更新，并进行渲染。如果我们使用宏任务来做数据更新，`UI` 会渲染两次。

`flushSchedulerQueue` 方法就是把队列中的任务依次取出，执行 `run` 方法，其实就是通知虚拟 `DOM` 触发 `patch` 过程。



## nextTick的作用

`nextTick` 保证回调代码在下一个 `DOM` 更新周期之后执行，保证我们能获取到最新的 `DOM` 结构，在更改了一些数据并影响到页面 `DOM` 结构，等到 `DOM` 更新后立即调用回调。

## 原理解析

我们传入 `Vue` 抛出的 `nextTick` 方法中的回调，为什么能够在 `dom` 更新并渲染后立即获取到呢？

首先，当我们修改数据影响到 `DOM` 时，`DOM Tree` 的修改是实时的，但是更新到视图 `DOM` 上是异步的。

就像我们刚开始说的，当数据发生改变时，会通知组件 `Watcher` 更新，这时会把 `update` 函数加入到 `flushBatcherQueue` 中，在同一个 `tick` 内产生的 `update` 会在同一个队列中，如果有组件重复更新，则只用加入最新的 `update`。

然后紧接着把我们传入 `nextTick` 中的回调加入到 `flushBatcherQueue` 中，此时触发更新的操作还没有执行，那么所有行为都在这个队列中。

因为是队列结构，所以会保证 `update` 的代码先更新，然后再执行 `nextTick` 的回调，因为我们是同步加入到队列中的，这些都是在同一次事件循环中进行的，并且都是作为微任务执行。
